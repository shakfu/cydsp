"""Type stubs for the cydsp._core C++ extension module."""

from __future__ import annotations

import enum
from typing import Self

import numpy as np
from numpy.typing import NDArray

def add(a: int, b: int) -> int: ...
def greet(name: str) -> str: ...

class filters:
    class BiquadDesign(enum.IntEnum):
        bilinear: int
        cookbook: int
        one_sided: int
        vicanek: int

    class Biquad:
        def __init__(self) -> None: ...
        def lowpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def lowpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def highpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def highpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def bandpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def bandpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def notch(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def notch_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def peak(
            self,
            freq: float,
            gain: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def peak_db(
            self,
            freq: float,
            db: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def high_shelf(
            self,
            freq: float,
            gain: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def high_shelf_db(
            self,
            freq: float,
            db: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def low_shelf(
            self,
            freq: float,
            gain: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def low_shelf_db(
            self,
            freq: float,
            db: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def allpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def allpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def add_gain(self, factor: float) -> Self: ...
        def add_gain_db(self, db: float) -> Self: ...
        def reset(self) -> None: ...
        def response(self, freq: float) -> complex: ...
        def response_db(self, freq: float) -> float: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...
        def process_inplace(self, buffer: np.ndarray) -> None: ...

class fft:
    class FFT:
        def __init__(self, size: int, fast_direction: int = ...) -> None: ...
        def size(self) -> int: ...
        def set_size(self, size: int) -> None: ...
        @staticmethod
        def fast_size_above(size: int) -> int: ...
        @staticmethod
        def fast_size_below(size: int) -> int: ...
        def fft(self, input: np.ndarray) -> NDArray[np.complex64]: ...
        def ifft(self, input: np.ndarray) -> NDArray[np.complex64]: ...

    class RealFFT:
        def __init__(self, size: int, fast_direction: int = ...) -> None: ...
        def size(self) -> int: ...
        def set_size(self, size: int) -> None: ...
        @staticmethod
        def fast_size_above(size: int) -> int: ...
        @staticmethod
        def fast_size_below(size: int) -> int: ...
        def fft(self, input: np.ndarray) -> NDArray[np.complex64]: ...
        def ifft(self, input: np.ndarray) -> NDArray[np.float32]: ...

class delay:
    class Delay:
        latency: int
        def __init__(self, capacity: int = ...) -> None: ...
        def reset(self, value: float = ...) -> None: ...
        def resize(self, capacity: int, value: float = ...) -> None: ...
        def process(
            self, input: np.ndarray, delay_samples: float
        ) -> NDArray[np.float32]: ...
        def process_varying(
            self, input: np.ndarray, delays: np.ndarray
        ) -> NDArray[np.float32]: ...

    class DelayCubic:
        latency: int
        def __init__(self, capacity: int = ...) -> None: ...
        def reset(self, value: float = ...) -> None: ...
        def resize(self, capacity: int, value: float = ...) -> None: ...
        def process(
            self, input: np.ndarray, delay_samples: float
        ) -> NDArray[np.float32]: ...
        def process_varying(
            self, input: np.ndarray, delays: np.ndarray
        ) -> NDArray[np.float32]: ...

class envelopes:
    class CubicLfo:
        def __init__(self, seed: int = ...) -> None: ...
        def reset(self) -> None: ...
        def set(
            self,
            low: float,
            high: float,
            rate: float,
            rate_variation: float = ...,
            depth_variation: float = ...,
        ) -> None: ...
        def next(self) -> float: ...
        def process(self, n: int) -> NDArray[np.float32]: ...

    class BoxFilter:
        def __init__(self, max_length: int) -> None: ...
        def resize(self, max_length: int) -> None: ...
        def set(self, length: int) -> None: ...
        def reset(self, fill: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class BoxStackFilter:
        def __init__(self, max_size: int, layers: int = ...) -> None: ...
        def set(self, size: int) -> None: ...
        def reset(self, fill: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class PeakHold:
        def __init__(self, max_length: int) -> None: ...
        def resize(self, max_length: int) -> None: ...
        def set(self, new_size: int, preserve_current_peak: bool = ...) -> None: ...
        def reset(self, fill: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class PeakDecayLinear:
        def __init__(self, max_length: int) -> None: ...
        def resize(self, max_length: int) -> None: ...
        def set(self, length: int) -> None: ...
        def reset(self, start: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

class spectral:
    class STFT:
        def __init__(
            self,
            channels: int,
            window_size: int,
            interval: int,
            history_length: int = ...,
            zero_padding: int = ...,
        ) -> None: ...
        def window_size(self) -> int: ...
        def fft_size(self) -> int: ...
        def interval(self) -> int: ...
        def bands(self) -> int: ...
        def latency(self) -> int: ...
        def reset(self) -> None: ...
        def analyse(self, input: np.ndarray) -> None: ...
        def analyse_channel(self, channel: int, input: np.ndarray) -> None: ...
        def get_spectrum(self) -> NDArray[np.complex64]: ...
        def get_spectrum_channel(self, channel: int) -> NDArray[np.complex64]: ...
        def set_spectrum_channel(self, channel: int, data: np.ndarray) -> None: ...

class rates:
    class Oversampler2x:
        def __init__(
            self,
            channels: int,
            max_block: int,
            half_latency: int = ...,
            pass_freq: float = ...,
        ) -> None: ...
        def reset(self) -> None: ...
        def latency(self) -> int: ...
        def up(self, input: np.ndarray) -> NDArray[np.float32]: ...
        def down(self, input: np.ndarray, low_samples: int) -> NDArray[np.float32]: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

class mix:
    class Hadamard:
        def __init__(self, size: int) -> None: ...
        def in_place(self, data: np.ndarray) -> NDArray[np.float32]: ...
        def scaling_factor(self) -> float: ...

    class Householder:
        def __init__(self, size: int) -> None: ...
        def in_place(self, data: np.ndarray) -> NDArray[np.float32]: ...

    @staticmethod
    def cheap_energy_crossfade(x: float) -> tuple[float, float]: ...
