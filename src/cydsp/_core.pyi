"""Type stubs for the cydsp._core C++ extension module."""

from __future__ import annotations

import enum
from typing import Self, overload

import numpy as np
from numpy.typing import NDArray

def add(a: int, b: int) -> int: ...
def greet(name: str) -> str: ...

class filters:
    class BiquadDesign(enum.IntEnum):
        bilinear = ...
        cookbook = ...
        one_sided = ...
        vicanek = ...

    class Biquad:
        def __init__(self) -> None: ...
        def lowpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def lowpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def highpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def highpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def bandpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def bandpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def notch(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def notch_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def peak(
            self,
            freq: float,
            gain: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def peak_db(
            self,
            freq: float,
            db: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def high_shelf(
            self,
            freq: float,
            gain: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def high_shelf_db(
            self,
            freq: float,
            db: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def low_shelf(
            self,
            freq: float,
            gain: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def low_shelf_db(
            self,
            freq: float,
            db: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def allpass(
            self,
            freq: float,
            octaves: float = ...,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def allpass_q(
            self,
            freq: float,
            q: float,
            design: filters.BiquadDesign = ...,
        ) -> Self: ...
        def add_gain(self, factor: float) -> Self: ...
        def add_gain_db(self, db: float) -> Self: ...
        def reset(self) -> None: ...
        def response(self, freq: float) -> complex: ...
        def response_db(self, freq: float) -> float: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...
        def process_inplace(self, buffer: np.ndarray) -> None: ...

class fft:
    class FFT:
        def __init__(self, size: int, fast_direction: int = ...) -> None: ...
        def size(self) -> int: ...
        def set_size(self, size: int) -> None: ...
        @staticmethod
        def fast_size_above(size: int) -> int: ...
        @staticmethod
        def fast_size_below(size: int) -> int: ...
        def fft(self, input: np.ndarray) -> NDArray[np.complex64]: ...
        def ifft(self, input: np.ndarray) -> NDArray[np.complex64]: ...

    class RealFFT:
        def __init__(self, size: int, fast_direction: int = ...) -> None: ...
        def size(self) -> int: ...
        def set_size(self, size: int) -> None: ...
        @staticmethod
        def fast_size_above(size: int) -> int: ...
        @staticmethod
        def fast_size_below(size: int) -> int: ...
        def fft(self, input: np.ndarray) -> NDArray[np.complex64]: ...
        def ifft(self, input: np.ndarray) -> NDArray[np.float32]: ...

class delay:
    class Delay:
        latency: int
        def __init__(self, capacity: int = ...) -> None: ...
        def reset(self, value: float = ...) -> None: ...
        def resize(self, capacity: int, value: float = ...) -> None: ...
        def process(
            self, input: np.ndarray, delay_samples: float
        ) -> NDArray[np.float32]: ...
        def process_varying(
            self, input: np.ndarray, delays: np.ndarray
        ) -> NDArray[np.float32]: ...

    class DelayCubic:
        latency: int
        def __init__(self, capacity: int = ...) -> None: ...
        def reset(self, value: float = ...) -> None: ...
        def resize(self, capacity: int, value: float = ...) -> None: ...
        def process(
            self, input: np.ndarray, delay_samples: float
        ) -> NDArray[np.float32]: ...
        def process_varying(
            self, input: np.ndarray, delays: np.ndarray
        ) -> NDArray[np.float32]: ...

class envelopes:
    class CubicLfo:
        def __init__(self, seed: int = ...) -> None: ...
        def reset(self) -> None: ...
        def set(
            self,
            low: float,
            high: float,
            rate: float,
            rate_variation: float = ...,
            depth_variation: float = ...,
        ) -> None: ...
        def next(self) -> float: ...
        def process(self, n: int) -> NDArray[np.float32]: ...

    class BoxFilter:
        def __init__(self, max_length: int) -> None: ...
        def resize(self, max_length: int) -> None: ...
        def set(self, length: int) -> None: ...
        def reset(self, fill: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class BoxStackFilter:
        def __init__(self, max_size: int, layers: int = ...) -> None: ...
        def set(self, size: int) -> None: ...
        def reset(self, fill: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class PeakHold:
        def __init__(self, max_length: int) -> None: ...
        def resize(self, max_length: int) -> None: ...
        def set(self, new_size: int, preserve_current_peak: bool = ...) -> None: ...
        def reset(self, fill: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class PeakDecayLinear:
        def __init__(self, max_length: int) -> None: ...
        def resize(self, max_length: int) -> None: ...
        def set(self, length: int) -> None: ...
        def reset(self, start: float = ...) -> None: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

class spectral:
    class STFT:
        def __init__(
            self,
            channels: int,
            window_size: int,
            interval: int,
            history_length: int = ...,
            zero_padding: int = ...,
        ) -> None: ...
        def window_size(self) -> int: ...
        def fft_size(self) -> int: ...
        def interval(self) -> int: ...
        def bands(self) -> int: ...
        def latency(self) -> int: ...
        def reset(self) -> None: ...
        def analyse(self, input: np.ndarray) -> None: ...
        def analyse_channel(self, channel: int, input: np.ndarray) -> None: ...
        def get_spectrum(self) -> NDArray[np.complex64]: ...
        def get_spectrum_channel(self, channel: int) -> NDArray[np.complex64]: ...
        def set_spectrum_channel(self, channel: int, data: np.ndarray) -> None: ...

class rates:
    class Oversampler2x:
        def __init__(
            self,
            channels: int,
            max_block: int,
            half_latency: int = ...,
            pass_freq: float = ...,
        ) -> None: ...
        def reset(self) -> None: ...
        def latency(self) -> int: ...
        def up(self, input: np.ndarray) -> NDArray[np.float32]: ...
        def down(self, input: np.ndarray, low_samples: int) -> NDArray[np.float32]: ...
        def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

class mix:
    class Hadamard:
        def __init__(self, size: int) -> None: ...
        def in_place(self, data: np.ndarray) -> NDArray[np.float32]: ...
        def scaling_factor(self) -> float: ...

    class Householder:
        def __init__(self, size: int) -> None: ...
        def in_place(self, data: np.ndarray) -> NDArray[np.float32]: ...

    @staticmethod
    def cheap_energy_crossfade(x: float) -> tuple[float, float]: ...

class daisysp:
    class oscillators:
        WAVE_SIN: int
        WAVE_TRI: int
        WAVE_SAW: int
        WAVE_RAMP: int
        WAVE_SQUARE: int
        WAVE_POLYBLEP_TRI: int
        WAVE_POLYBLEP_SAW: int
        WAVE_POLYBLEP_SQUARE: int
        BLOSC_WAVE_TRIANGLE: int
        BLOSC_WAVE_SAW: int
        BLOSC_WAVE_SQUARE: int
        BLOSC_WAVE_OFF: int

        class Oscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_amp(self, amp: float) -> None: ...
            def set_waveform(self, waveform: int) -> None: ...
            def set_pw(self, pw: float) -> None: ...
            def phase_add(self, phase: float) -> None: ...
            def reset(self, phase: float = ...) -> None: ...
            def is_eor(self) -> bool: ...
            def is_eoc(self) -> bool: ...
            def is_rising(self) -> bool: ...
            def is_falling(self) -> bool: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Fm2:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_frequency(self, freq: float) -> None: ...
            def set_ratio(self, ratio: float) -> None: ...
            def set_index(self, index: float) -> None: ...
            def get_index(self) -> float: ...
            def reset(self) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class FormantOscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_formant_freq(self, freq: float) -> None: ...
            def set_carrier_freq(self, freq: float) -> None: ...
            def set_phase_shift(self, ps: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class HarmonicOscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_first_harm_idx(self, idx: int) -> None: ...
            def set_amplitudes(self, amplitudes: np.ndarray) -> None: ...
            def set_single_amp(self, amp: float, idx: int) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class OscillatorBank:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_amplitudes(self, amplitudes: np.ndarray) -> None: ...
            def set_single_amp(self, amp: float, idx: int) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class VariableSawOscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_pw(self, pw: float) -> None: ...
            def set_waveshape(self, waveshape: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class VariableShapeOscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_pw(self, pw: float) -> None: ...
            def set_waveshape(self, waveshape: float) -> None: ...
            def set_sync(self, enable_sync: bool) -> None: ...
            def set_sync_freq(self, freq: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class VosimOscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_form1_freq(self, freq: float) -> None: ...
            def set_form2_freq(self, freq: float) -> None: ...
            def set_shape(self, shape: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class ZOscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_formant_freq(self, freq: float) -> None: ...
            def set_shape(self, shape: float) -> None: ...
            def set_mode(self, mode: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class BlOsc:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_amp(self, amp: float) -> None: ...
            def set_pw(self, pw: float) -> None: ...
            def set_waveform(self, waveform: int) -> None: ...
            def reset(self) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

    class filters:
        class Svf:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_res(self, res: float) -> None: ...
            def set_drive(self, drive: float) -> None: ...
            def process_sample(
                self, in_: float
            ) -> tuple[float, float, float, float, float]: ...
            def low(self) -> float: ...
            def high(self) -> float: ...
            def band(self) -> float: ...
            def notch(self) -> float: ...
            def peak(self) -> float: ...
            def process_low(self, input: np.ndarray) -> NDArray[np.float32]: ...
            def process_high(self, input: np.ndarray) -> NDArray[np.float32]: ...
            def process_band(self, input: np.ndarray) -> NDArray[np.float32]: ...
            def process_notch(self, input: np.ndarray) -> NDArray[np.float32]: ...
            def process_peak(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class OnePoleFM(enum.IntEnum):
            LOW_PASS = ...
            HIGH_PASS = ...

        class OnePole:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def reset(self) -> None: ...
            def set_frequency(self, freq: float) -> None: ...
            def set_filter_mode(self, mode: daisysp.filters.OnePoleFM) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class LadderFilterMode(enum.IntEnum):
            LP24 = ...
            LP12 = ...
            BP24 = ...
            BP12 = ...
            HP24 = ...
            HP12 = ...

        class LadderFilter:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_res(self, res: float) -> None: ...
            def set_passband_gain(self, pbg: float) -> None: ...
            def set_input_drive(self, drv: float) -> None: ...
            def set_filter_mode(
                self, mode: daisysp.filters.LadderFilterMode
            ) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Soap:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_center_freq(self, freq: float) -> None: ...
            def set_filter_bandwidth(self, bandwidth: float) -> None: ...
            def process_sample(self, in_: float) -> tuple[float, float]: ...
            def bandpass(self) -> float: ...
            def bandreject(self) -> float: ...
            def process_bandpass(self, input: np.ndarray) -> NDArray[np.float32]: ...
            def process_bandreject(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Allpass:
            def __init__(self, sample_rate: float, max_size: int = ...) -> None: ...
            def set_freq(self, looptime: float) -> None: ...
            def set_rev_time(self, revtime: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class ATone:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def get_freq(self) -> float: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class DaisyBiquad:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_res(self, res: float) -> None: ...
            def set_cutoff(self, cutoff: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Comb:
            def __init__(self, sample_rate: float, max_size: int = ...) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_period(self, looptime: float) -> None: ...
            def set_rev_time(self, revtime: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Mode:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_q(self, q: float) -> None: ...
            def clear(self) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class MoogLadder:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_res(self, res: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class NlFilt:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_coefficients(
                self, a: float, b: float, d: float, C: float, L: float
            ) -> None: ...
            def set_a(self, a: float) -> None: ...
            def set_b(self, b: float) -> None: ...
            def set_d(self, d: float) -> None: ...
            def set_c(self, C: float) -> None: ...
            def set_l(self, L: float) -> None: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Tone:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def get_freq(self) -> float: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class effects:
        class Autowah:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_wah(self, wah: float) -> None: ...
            def set_dry_wet(self, drywet: float) -> None: ...
            def set_level(self, level: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Chorus:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_lfo_depth(self, depth: float) -> None: ...
            def set_lfo_freq(self, freq: float) -> None: ...
            def set_delay(self, delay: float) -> None: ...
            def set_delay_ms(self, ms: float) -> None: ...
            def set_feedback(self, feedback: float) -> None: ...
            def get_left(self) -> float: ...
            def get_right(self) -> float: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...
            def process_stereo(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Decimator:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_downsample_factor(self, factor: float) -> None: ...
            def set_bitcrush_factor(self, factor: float) -> None: ...
            def set_bits_to_crush(self, bits: int) -> None: ...
            def set_smooth_crushing(self, enable: bool) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Flanger:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_feedback(self, feedback: float) -> None: ...
            def set_lfo_depth(self, depth: float) -> None: ...
            def set_lfo_freq(self, freq: float) -> None: ...
            def set_delay(self, delay: float) -> None: ...
            def set_delay_ms(self, ms: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Overdrive:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_drive(self, drive: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Phaser:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_poles(self, poles: int) -> None: ...
            def set_lfo_depth(self, depth: float) -> None: ...
            def set_lfo_freq(self, freq: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_feedback(self, feedback: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class PitchShifter:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_transposition(self, semitones: float) -> None: ...
            def set_del_size(self, size: int) -> None: ...
            def set_fun(self, fun: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class SampleRateReducer:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Tremolo:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_waveform(self, waveform: int) -> None: ...
            def set_depth(self, depth: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Wavefolder:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def set_offset(self, offset: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Bitcrush:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_bit_depth(self, depth: int) -> None: ...
            def set_crush_rate(self, rate: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Fold:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_increment(self, incr: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class ReverbSc:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_feedback(self, feedback: float) -> None: ...
            def set_lp_freq(self, freq: float) -> None: ...
            def process_sample(self, in1: float, in2: float) -> tuple[float, float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class dynamics:
        CROSSFADE_LIN: int
        CROSSFADE_CPOW: int
        CROSSFADE_LOG: int
        CROSSFADE_EXP: int

        class CrossFade:
            def __init__(self) -> None: ...
            def init(self, curve: int = ...) -> None: ...
            def set_pos(self, pos: float) -> None: ...
            def set_curve(self, curve: int) -> None: ...
            def process_sample(self, in1: float, in2: float) -> float: ...
            def process(
                self, input1: np.ndarray, input2: np.ndarray
            ) -> NDArray[np.float32]: ...

        class Limiter:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def process(
                self, input: np.ndarray, pre_gain: float = ...
            ) -> NDArray[np.float32]: ...

        class Balance:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_cutoff(self, cutoff: float) -> None: ...
            def process_sample(self, sig: float, comp: float) -> float: ...
            def process(
                self, sig: np.ndarray, comp: np.ndarray
            ) -> NDArray[np.float32]: ...

        class Compressor:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_ratio(self, ratio: float) -> None: ...
            def set_threshold(self, threshold: float) -> None: ...
            def set_attack(self, attack: float) -> None: ...
            def set_release(self, release: float) -> None: ...
            def set_makeup(self, gain: float) -> None: ...
            def auto_makeup(self, enable: bool) -> None: ...
            def get_ratio(self) -> float: ...
            def get_threshold(self) -> float: ...
            def get_attack(self) -> float: ...
            def get_release(self) -> float: ...
            def get_makeup(self) -> float: ...
            def get_gain(self) -> float: ...
            def process_sample(self, in_: float) -> float: ...
            def apply(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class control:
        ADENV_SEG_IDLE: int
        ADENV_SEG_ATTACK: int
        ADENV_SEG_DECAY: int
        ADSR_SEG_IDLE: int
        ADSR_SEG_ATTACK: int
        ADSR_SEG_DECAY: int
        ADSR_SEG_RELEASE: int

        class AdEnv:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trigger(self) -> None: ...
            def set_time(self, seg: int, time: float) -> None: ...
            def set_curve(self, scalar: float) -> None: ...
            def set_min(self, min: float) -> None: ...
            def set_max(self, max: float) -> None: ...
            def get_value(self) -> float: ...
            def get_current_segment(self) -> int: ...
            def is_running(self) -> bool: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Adsr:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float, block_size: int = ...) -> None: ...
            def retrigger(self, hard: bool) -> None: ...
            def set_attack_time(self, time: float) -> None: ...
            def set_decay_time(self, time: float) -> None: ...
            def set_release_time(self, time: float) -> None: ...
            def set_sustain_level(self, level: float) -> None: ...
            def set_time(self, seg: int, time: float) -> None: ...
            def get_current_segment(self) -> int: ...
            def is_running(self) -> bool: ...
            def process_sample(self, gate: bool) -> float: ...
            def process(self, gate: np.ndarray) -> NDArray[np.float32]: ...

        class Phasor:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float, freq: float = ...) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def get_freq(self) -> float: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Line:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def start(self, start: float, end: float, dur: float) -> None: ...
            def process(self, n: int) -> tuple[NDArray[np.float32], bool]: ...

    class noise:
        class WhiteNoise:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_amp(self, amp: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Dust:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def set_density(self, density: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class ClockedNoise:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def sync(self) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class FractalRandomGenerator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_color(self, color: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class GrainletOscillator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_formant_freq(self, freq: float) -> None: ...
            def set_shape(self, shape: float) -> None: ...
            def set_bleed(self, bleed: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Particle:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_resonance(self, res: float) -> None: ...
            def set_random_freq(self, freq: float) -> None: ...
            def set_density(self, density: float) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def set_spread(self, spread: float) -> None: ...
            def set_sync(self, sync: bool) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class SmoothRandomGenerator:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

    class drums:
        class AnalogBassDrum:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trig(self) -> None: ...
            def set_sustain(self, sustain: bool) -> None: ...
            def set_accent(self, accent: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_tone(self, tone: float) -> None: ...
            def set_decay(self, decay: float) -> None: ...
            def set_attack_fm_amount(self, amount: float) -> None: ...
            def set_self_fm_amount(self, amount: float) -> None: ...
            def process_sample(self, trigger: bool = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class AnalogSnareDrum:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trig(self) -> None: ...
            def set_sustain(self, sustain: bool) -> None: ...
            def set_accent(self, accent: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_tone(self, tone: float) -> None: ...
            def set_decay(self, decay: float) -> None: ...
            def set_snappy(self, snappy: float) -> None: ...
            def process_sample(self, trigger: bool = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class HiHat:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trig(self) -> None: ...
            def set_sustain(self, sustain: bool) -> None: ...
            def set_accent(self, accent: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_tone(self, tone: float) -> None: ...
            def set_decay(self, decay: float) -> None: ...
            def set_noisiness(self, noisiness: float) -> None: ...
            def process_sample(self, trigger: bool = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class SyntheticBassDrum:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trig(self) -> None: ...
            def set_sustain(self, sustain: bool) -> None: ...
            def set_accent(self, accent: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_tone(self, tone: float) -> None: ...
            def set_decay(self, decay: float) -> None: ...
            def set_dirtiness(self, dirtiness: float) -> None: ...
            def set_fm_envelope_amount(self, amount: float) -> None: ...
            def set_fm_envelope_decay(self, decay: float) -> None: ...
            def process_sample(self, trigger: bool = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class SyntheticSnareDrum:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trig(self) -> None: ...
            def set_sustain(self, sustain: bool) -> None: ...
            def set_accent(self, accent: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_fm_amount(self, amount: float) -> None: ...
            def set_decay(self, decay: float) -> None: ...
            def set_snappy(self, snappy: float) -> None: ...
            def process_sample(self, trigger: bool = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

    class physical_modeling:
        PLUCK_MODE_RECURSIVE: int
        PLUCK_MODE_WEIGHTED_AVERAGE: int

        class Drip:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float, dettack: float) -> None: ...
            def process_sample(self, trig: bool) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class String:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def reset(self) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_non_linearity(self, amount: float) -> None: ...
            def set_brightness(self, brightness: float) -> None: ...
            def set_damping(self, damping: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class ModalVoice:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trig(self) -> None: ...
            def set_sustain(self, sustain: bool) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_accent(self, accent: float) -> None: ...
            def set_structure(self, structure: float) -> None: ...
            def set_brightness(self, brightness: float) -> None: ...
            def set_damping(self, damping: float) -> None: ...
            def get_aux(self) -> float: ...
            def process_sample(self, trigger: bool = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Resonator:
            def __init__(self) -> None: ...
            def init(
                self, position: float, resolution: int, sample_rate: float
            ) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_structure(self, structure: float) -> None: ...
            def set_brightness(self, brightness: float) -> None: ...
            def set_damping(self, damping: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class StringVoice:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def trig(self) -> None: ...
            def reset(self) -> None: ...
            def set_sustain(self, sustain: bool) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_accent(self, accent: float) -> None: ...
            def set_structure(self, structure: float) -> None: ...
            def set_brightness(self, brightness: float) -> None: ...
            def set_damping(self, damping: float) -> None: ...
            def get_aux(self) -> float: ...
            def process_sample(self, trigger: bool = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Pluck:
            def __init__(
                self, sample_rate: float, npt: int = ..., mode: int = ...
            ) -> None: ...
            def set_amp(self, amp: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def set_decay(self, decay: float) -> None: ...
            def set_damp(self, damp: float) -> None: ...
            def set_mode(self, mode: int) -> None: ...
            def process_sample(self, trig: float) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

    class utility:
        class DcBlock:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class DelayLine:
            def __init__(self) -> None: ...
            def init(self) -> None: ...
            def reset(self) -> None: ...
            def set_delay(self, delay: float) -> None: ...
            def write(self, sample: float) -> None: ...
            def read(self) -> float: ...
            def read_at(self, delay: float) -> float: ...
            def read_hermite(self, delay: float) -> float: ...
            def process(
                self, input: np.ndarray, delay_samples: float
            ) -> NDArray[np.float32]: ...

        class LooperMode(enum.IntEnum):
            NORMAL = ...
            ONETIME_DUB = ...
            REPLACE = ...
            FRIPPERTRONICS = ...

        class Looper:
            def __init__(self, size: int = ...) -> None: ...
            def trig_record(self) -> None: ...
            def set_mode(self, mode: daisysp.utility.LooperMode) -> None: ...
            def get_mode(self) -> daisysp.utility.LooperMode: ...
            def set_reverse(self, state: bool) -> None: ...
            def toggle_reverse(self) -> None: ...
            def get_reverse(self) -> bool: ...
            def set_half_speed(self, state: bool) -> None: ...
            def toggle_half_speed(self) -> None: ...
            def get_half_speed(self) -> bool: ...
            def clear(self) -> None: ...
            def recording(self) -> bool: ...
            def is_near_beginning(self) -> bool: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Maytrig:
            def __init__(self) -> None: ...
            def process(self, prob: float) -> float: ...

        class Metro:
            def __init__(self) -> None: ...
            def init(self, freq: float, sample_rate: float) -> None: ...
            def set_freq(self, freq: float) -> None: ...
            def get_freq(self) -> float: ...
            def reset(self) -> None: ...
            def process_sample(self) -> bool: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class SampleHoldMode(enum.IntEnum):
            SAMPLE_HOLD = ...
            TRACK_HOLD = ...

        class SampleHold:
            def __init__(self) -> None: ...
            def process(
                self,
                trigger: bool,
                input: float,
                mode: daisysp.utility.SampleHoldMode = ...,
            ) -> float: ...

        class Jitter:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float) -> None: ...
            def set_cps_min(self, cps_min: float) -> None: ...
            def set_cps_max(self, cps_max: float) -> None: ...
            def set_amp(self, amp: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Port:
            def __init__(self) -> None: ...
            def init(self, sample_rate: float, htime: float) -> None: ...
            def set_htime(self, htime: float) -> None: ...
            def get_htime(self) -> float: ...
            def process_sample(self, in_: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

class stk:
    @staticmethod
    def set_sample_rate(rate: float) -> None: ...
    @staticmethod
    def sample_rate() -> float: ...

    class generators:
        ADSR_ATTACK: int
        ADSR_DECAY: int
        ADSR_SUSTAIN: int
        ADSR_RELEASE: int
        ADSR_IDLE: int

        class SineWave:
            def __init__(self) -> None: ...
            def reset(self) -> None: ...
            def set_rate(self, rate: float) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def add_time(self, time: float) -> None: ...
            def add_phase(self, phase: float) -> None: ...
            def add_phase_offset(self, phase_offset: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Noise:
            def __init__(self, seed: int = ...) -> None: ...
            def set_seed(self, seed: int = ...) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Blit:
            def __init__(self, frequency: float = ...) -> None: ...
            def reset(self) -> None: ...
            def set_phase(self, phase: float) -> None: ...
            def get_phase(self) -> float: ...
            def set_frequency(self, frequency: float) -> None: ...
            def set_harmonics(self, n_harmonics: int = ...) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class BlitSaw:
            def __init__(self, frequency: float = ...) -> None: ...
            def reset(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def set_harmonics(self, n_harmonics: int = ...) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class BlitSquare:
            def __init__(self, frequency: float = ...) -> None: ...
            def reset(self) -> None: ...
            def set_phase(self, phase: float) -> None: ...
            def get_phase(self) -> float: ...
            def set_frequency(self, frequency: float) -> None: ...
            def set_harmonics(self, n_harmonics: int = ...) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class ADSR:
            def __init__(self) -> None: ...
            def key_on(self) -> None: ...
            def key_off(self) -> None: ...
            def set_attack_rate(self, rate: float) -> None: ...
            def set_attack_target(self, target: float) -> None: ...
            def set_decay_rate(self, rate: float) -> None: ...
            def set_sustain_level(self, level: float) -> None: ...
            def set_release_rate(self, rate: float) -> None: ...
            def set_attack_time(self, time: float) -> None: ...
            def set_decay_time(self, time: float) -> None: ...
            def set_release_time(self, time: float) -> None: ...
            def set_all_times(
                self,
                attack_time: float,
                decay_time: float,
                sustain_level: float,
                release_time: float,
            ) -> None: ...
            def set_target(self, target: float) -> None: ...
            def set_value(self, value: float) -> None: ...
            def get_state(self) -> int: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Asymp:
            def __init__(self) -> None: ...
            def key_on(self) -> None: ...
            def key_off(self) -> None: ...
            def set_tau(self, tau: float) -> None: ...
            def set_time(self, time: float) -> None: ...
            def set_t60(self, t60: float) -> None: ...
            def set_target(self, target: float) -> None: ...
            def set_value(self, value: float) -> None: ...
            def get_state(self) -> int: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Envelope:
            def __init__(self) -> None: ...
            def key_on(self, target: float = ...) -> None: ...
            def key_off(self, target: float = ...) -> None: ...
            def set_rate(self, rate: float) -> None: ...
            def set_time(self, time: float) -> None: ...
            def set_target(self, target: float) -> None: ...
            def set_value(self, value: float) -> None: ...
            def get_state(self) -> int: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Modulate:
            def __init__(self) -> None: ...
            def reset(self) -> None: ...
            def set_vibrato_rate(self, rate: float) -> None: ...
            def set_vibrato_gain(self, gain: float) -> None: ...
            def set_random_rate(self, rate: float) -> None: ...
            def set_random_gain(self, gain: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

    class filters:
        class BiQuad:
            def __init__(self) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def clear(self) -> None: ...
            def phase_delay(self, frequency: float) -> float: ...
            def set_coefficients(
                self,
                b0: float,
                b1: float,
                b2: float,
                a1: float,
                a2: float,
                clear_state: bool = ...,
            ) -> None: ...
            def set_b0(self, b0: float) -> None: ...
            def set_b1(self, b1: float) -> None: ...
            def set_b2(self, b2: float) -> None: ...
            def set_a1(self, a1: float) -> None: ...
            def set_a2(self, a2: float) -> None: ...
            def set_resonance(
                self, frequency: float, radius: float, normalize: bool = ...
            ) -> None: ...
            def set_notch(self, frequency: float, radius: float) -> None: ...
            def set_low_pass(self, fc: float, q: float = ...) -> None: ...
            def set_high_pass(self, fc: float, q: float = ...) -> None: ...
            def set_band_pass(self, fc: float, q: float) -> None: ...
            def set_band_reject(self, fc: float, q: float) -> None: ...
            def set_all_pass(self, fc: float, q: float) -> None: ...
            def set_equal_gain_zeroes(self) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class OnePole:
            def __init__(self, pole: float = ...) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def clear(self) -> None: ...
            def phase_delay(self, frequency: float) -> float: ...
            def set_b0(self, b0: float) -> None: ...
            def set_a1(self, a1: float) -> None: ...
            def set_coefficients(
                self, b0: float, a1: float, clear_state: bool = ...
            ) -> None: ...
            def set_pole(self, pole: float) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class OneZero:
            def __init__(self, zero: float = ...) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def clear(self) -> None: ...
            def phase_delay(self, frequency: float) -> float: ...
            def set_b0(self, b0: float) -> None: ...
            def set_b1(self, b1: float) -> None: ...
            def set_coefficients(
                self, b0: float, b1: float, clear_state: bool = ...
            ) -> None: ...
            def set_zero(self, zero: float) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class TwoPole:
            def __init__(self) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def clear(self) -> None: ...
            def phase_delay(self, frequency: float) -> float: ...
            def set_b0(self, b0: float) -> None: ...
            def set_a1(self, a1: float) -> None: ...
            def set_a2(self, a2: float) -> None: ...
            def set_coefficients(
                self, b0: float, a1: float, a2: float, clear_state: bool = ...
            ) -> None: ...
            def set_resonance(
                self, frequency: float, radius: float, normalize: bool = ...
            ) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class TwoZero:
            def __init__(self) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def clear(self) -> None: ...
            def phase_delay(self, frequency: float) -> float: ...
            def set_b0(self, b0: float) -> None: ...
            def set_b1(self, b1: float) -> None: ...
            def set_b2(self, b2: float) -> None: ...
            def set_coefficients(
                self,
                b0: float,
                b1: float,
                b2: float,
                clear_state: bool = ...,
            ) -> None: ...
            def set_notch(self, frequency: float, radius: float) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class PoleZero:
            def __init__(self) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def clear(self) -> None: ...
            def phase_delay(self, frequency: float) -> float: ...
            def set_b0(self, b0: float) -> None: ...
            def set_b1(self, b1: float) -> None: ...
            def set_a1(self, a1: float) -> None: ...
            def set_coefficients(
                self, b0: float, b1: float, a1: float, clear_state: bool = ...
            ) -> None: ...
            def set_allpass(self, coefficient: float) -> None: ...
            def set_block_zero(self, pole: float = ...) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Resonate:
            def __init__(self) -> None: ...
            def set_resonance(self, frequency: float, radius: float) -> None: ...
            def set_notch(self, frequency: float, radius: float) -> None: ...
            def set_equal_gain_zeroes(self) -> None: ...
            def key_on(self) -> None: ...
            def key_off(self) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class FormSwep:
            def __init__(self) -> None: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def clear(self) -> None: ...
            def phase_delay(self, frequency: float) -> float: ...
            def set_resonance(self, frequency: float, radius: float) -> None: ...
            def set_states(
                self, frequency: float, radius: float, gain: float = ...
            ) -> None: ...
            def set_targets(
                self, frequency: float, radius: float, gain: float = ...
            ) -> None: ...
            def set_sweep_rate(self, rate: float) -> None: ...
            def set_sweep_time(self, time: float) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class delays:
        class Delay:
            def __init__(self, delay: int = ..., max_delay: int = ...) -> None: ...
            def clear(self) -> None: ...
            def set_maximum_delay(self, delay: int) -> None: ...
            def set_delay(self, delay: int) -> None: ...
            def get_delay(self) -> int: ...
            def tap_out(self, tap_delay: int) -> float: ...
            def tap_in(self, value: float, tap_delay: int) -> None: ...
            def next_out(self) -> float: ...
            def energy(self) -> float: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class DelayA:
            def __init__(self, delay: float = ..., max_delay: int = ...) -> None: ...
            def clear(self) -> None: ...
            def set_maximum_delay(self, delay: int) -> None: ...
            def set_delay(self, delay: float) -> None: ...
            def get_delay(self) -> float: ...
            def next_out(self) -> float: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class DelayL:
            def __init__(self, delay: float = ..., max_delay: int = ...) -> None: ...
            def clear(self) -> None: ...
            def set_maximum_delay(self, delay: int) -> None: ...
            def set_delay(self, delay: float) -> None: ...
            def get_delay(self) -> float: ...
            def tap_out(self, tap_delay: int) -> float: ...
            def tap_in(self, value: float, tap_delay: int) -> None: ...
            def next_out(self) -> float: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class TapDelay:
            def __init__(self, taps: list[int] = ..., max_delay: int = ...) -> None: ...
            def clear(self) -> None: ...
            def set_maximum_delay(self, delay: int) -> None: ...
            def set_tap_delays(self, taps: list[int]) -> None: ...
            def get_tap_delays(self) -> list[int]: ...
            def set_gain(self, gain: float) -> None: ...
            def get_gain(self) -> float: ...
            def process_sample(self, input: float) -> list[float]: ...

    class effects:
        class FreeVerb:
            def __init__(self) -> None: ...
            def clear(self) -> None: ...
            def set_effect_mix(self, mix: float) -> None: ...
            def set_room_size(self, value: float) -> None: ...
            def get_room_size(self) -> float: ...
            def set_damping(self, value: float) -> None: ...
            def get_damping(self) -> float: ...
            def set_width(self, value: float) -> None: ...
            def get_width(self) -> float: ...
            def set_mode(self, frozen: bool) -> None: ...
            def get_mode(self) -> float: ...
            def process_sample(
                self, input_l: float, input_r: float = ...
            ) -> tuple[float, float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...
            def process_mono(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class JCRev:
            def __init__(self, t60: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_t60(self, t60: float) -> None: ...
            def set_effect_mix(self, mix: float) -> None: ...
            def process_sample(self, input: float) -> tuple[float, float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class NRev:
            def __init__(self, t60: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_t60(self, t60: float) -> None: ...
            def set_effect_mix(self, mix: float) -> None: ...
            def process_sample(self, input: float) -> tuple[float, float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class PRCRev:
            def __init__(self, t60: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_t60(self, t60: float) -> None: ...
            def set_effect_mix(self, mix: float) -> None: ...
            def process_sample(self, input: float) -> tuple[float, float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Echo:
            def __init__(self, max_delay: int = ...) -> None: ...
            def clear(self) -> None: ...
            def set_effect_mix(self, mix: float) -> None: ...
            def set_maximum_delay(self, delay: int) -> None: ...
            def set_delay(self, delay: int) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Chorus:
            def __init__(self, base_delay: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_effect_mix(self, mix: float) -> None: ...
            def set_mod_depth(self, depth: float) -> None: ...
            def set_mod_frequency(self, frequency: float) -> None: ...
            def process_sample(self, input: float) -> tuple[float, float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class PitShift:
            def __init__(self) -> None: ...
            def clear(self) -> None: ...
            def set_effect_mix(self, mix: float) -> None: ...
            def set_shift(self, shift: float) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class LentPitShift:
            def __init__(self, shift: float = ..., window_size: int = ...) -> None: ...
            def clear(self) -> None: ...
            def set_shift(self, shift: float) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class instruments:
        class Clarinet:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Flute:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def set_jet_reflection(self, coefficient: float) -> None: ...
            def set_end_reflection(self, coefficient: float) -> None: ...
            def set_jet_delay(self, delay: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Brass:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def set_lip(self, frequency: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Bowed:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def set_vibrato(self, gain: float) -> None: ...
            def start_bowing(self, amplitude: float, rate: float) -> None: ...
            def stop_bowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Plucked:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Sitar:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class StifKarp:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def set_stretch(self, stretch: float) -> None: ...
            def set_base_loop_gain(self, gain: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Saxofony:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def set_blow_position(self, position: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Recorder:
            def __init__(self) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class BlowBotl:
            def __init__(self) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class BlowHole:
            def __init__(self, lowest_frequency: float) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def set_tonehole(self, value: float) -> None: ...
            def set_vent(self, value: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Whistle:
            def __init__(self) -> None: ...
            def clear(self) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def note_on(self, frequency: float, amplitude: float) -> None: ...
            def note_off(self, amplitude: float) -> None: ...
            def control_change(self, number: int, value: float) -> None: ...
            def start_blowing(self, amplitude: float, rate: float) -> None: ...
            def stop_blowing(self, rate: float) -> None: ...
            def process_sample(self) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Guitar:
            def __init__(self, n_strings: int = ..., body_file: str = ...) -> None: ...
            def clear(self) -> None: ...
            def set_pluck_position(
                self, position: float, string: int = ...
            ) -> None: ...
            def set_loop_gain(self, gain: float, string: int = ...) -> None: ...
            def set_frequency(self, frequency: float, string: int = ...) -> None: ...
            def note_on(
                self, frequency: float, amplitude: float, string: int = ...
            ) -> None: ...
            def note_off(self, amplitude: float, string: int = ...) -> None: ...
            def control_change(
                self, number: int, value: float, string: int = ...
            ) -> None: ...
            def process_sample(self, input: float = ...) -> float: ...
            def process(self, n: int) -> NDArray[np.float32]: ...

        class Twang:
            def __init__(self, lowest_frequency: float = ...) -> None: ...
            def clear(self) -> None: ...
            def set_lowest_frequency(self, frequency: float) -> None: ...
            def set_frequency(self, frequency: float) -> None: ...
            def set_pluck_position(self, position: float) -> None: ...
            def set_loop_gain(self, gain: float) -> None: ...
            def set_loop_filter(self, coefficients: list[float]) -> None: ...
            def process_sample(self, input: float) -> float: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

class madronalib:
    BLOCK_SIZE: int

    @overload
    @staticmethod
    def amp_to_db(amplitude: float) -> float: ...
    @overload
    @staticmethod
    def amp_to_db(amplitude: np.ndarray) -> NDArray[np.float32]: ...
    @overload
    @staticmethod
    def db_to_amp(db: float) -> float: ...
    @overload
    @staticmethod
    def db_to_amp(db: np.ndarray) -> NDArray[np.float32]: ...

    class reverbs:
        class FDN4:
            def __init__(self) -> None: ...
            def set_delays_in_samples(self, times: list[float]) -> None: ...
            def set_filter_cutoffs(self, omegas: list[float]) -> None: ...
            def set_feedback_gains(self, gains: list[float]) -> None: ...
            def get_feedback_gains(self) -> list[float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class FDN8:
            def __init__(self) -> None: ...
            def set_delays_in_samples(self, times: list[float]) -> None: ...
            def set_filter_cutoffs(self, omegas: list[float]) -> None: ...
            def set_feedback_gains(self, gains: list[float]) -> None: ...
            def get_feedback_gains(self) -> list[float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class FDN16:
            def __init__(self) -> None: ...
            def set_delays_in_samples(self, times: list[float]) -> None: ...
            def set_filter_cutoffs(self, omegas: list[float]) -> None: ...
            def set_feedback_gains(self, gains: list[float]) -> None: ...
            def get_feedback_gains(self) -> list[float]: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class delays:
        class PitchbendableDelay:
            def __init__(self) -> None: ...
            def set_max_delay_in_samples(self, max_delay: float) -> None: ...
            def clear(self) -> None: ...
            def process(
                self, input: np.ndarray, delay_samples: np.ndarray
            ) -> NDArray[np.float32]: ...

    class resampling:
        class Downsampler:
            def __init__(self, octaves: int) -> None: ...
            def clear(self) -> None: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Upsampler:
            def __init__(self, octaves: int) -> None: ...
            def clear(self) -> None: ...
            def process(
                self, input: np.ndarray, octaves: int
            ) -> NDArray[np.float32]: ...

    class generators:
        class OneShotGen:
            def __init__(self) -> None: ...
            def trigger(self) -> None: ...
            def process_sample(self, cycles_per_sample: float) -> float: ...
            def process(self, cycles_per_sample: np.ndarray) -> NDArray[np.float32]: ...

        class LinearGlide:
            def __init__(self) -> None: ...
            def set_glide_time_in_samples(self, time: float) -> None: ...
            def set_value(self, value: float) -> None: ...
            def clear(self) -> None: ...
            def process(self, target: float, n: int) -> NDArray[np.float32]: ...

        class SampleAccurateLinearGlide:
            def __init__(self) -> None: ...
            def set_glide_time_in_samples(self, time: float) -> None: ...
            def set_value(self, value: float) -> None: ...
            def clear(self) -> None: ...
            def process_sample(self, target: float) -> float: ...
            def process(self, target: float, n: int) -> NDArray[np.float32]: ...

        class TempoLock:
            def __init__(self) -> None: ...
            def clear(self) -> None: ...
            def process(
                self, phasor: np.ndarray, ratio: float, inv_sample_rate: float
            ) -> NDArray[np.float32]: ...

    class projections:
        @overload
        @staticmethod
        def smoothstep(x: float) -> float: ...
        @overload
        @staticmethod
        def smoothstep(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def bell(x: float) -> float: ...
        @overload
        @staticmethod
        def bell(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_in(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_in(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_out(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_out(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_in_out(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_in_out(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_in_cubic(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_in_cubic(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_out_cubic(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_out_cubic(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_in_out_cubic(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_in_out_cubic(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_in_quartic(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_in_quartic(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_out_quartic(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_out_quartic(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def ease_in_out_quartic(x: float) -> float: ...
        @overload
        @staticmethod
        def ease_in_out_quartic(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def overshoot(x: float) -> float: ...
        @overload
        @staticmethod
        def overshoot(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def flip(x: float) -> float: ...
        @overload
        @staticmethod
        def flip(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def squared(x: float) -> float: ...
        @overload
        @staticmethod
        def squared(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def flatcenter(x: float) -> float: ...
        @overload
        @staticmethod
        def flatcenter(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def bisquared(x: float) -> float: ...
        @overload
        @staticmethod
        def bisquared(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def inv_bisquared(x: float) -> float: ...
        @overload
        @staticmethod
        def inv_bisquared(input: np.ndarray) -> NDArray[np.float32]: ...
        @overload
        @staticmethod
        def clip(x: float) -> float: ...
        @overload
        @staticmethod
        def clip(input: np.ndarray) -> NDArray[np.float32]: ...

    class windows:
        @staticmethod
        def hamming(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def blackman(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def flat_top(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def triangle(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def raised_cosine(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def rectangle(size: int) -> NDArray[np.float32]: ...

class hisstools:
    class convolution:
        class LatencyMode(enum.IntEnum):
            zero = ...
            short_ = ...
            medium = ...

        class MonoConvolve:
            def __init__(self, max_length: int, latency: int = ...) -> None: ...
            def set_ir(self, ir: np.ndarray, resize: bool = ...) -> None: ...
            def reset(self) -> None: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

        class Convolver:
            num_ins: int
            num_outs: int
            def __init__(
                self, num_ins: int, num_outs: int, latency: int = ...
            ) -> None: ...
            def set_ir(
                self, in_chan: int, out_chan: int, ir: np.ndarray, resize: bool = ...
            ) -> None: ...
            def clear(self, resize: bool = ...) -> None: ...
            def reset(self) -> None: ...
            def process(self, input: np.ndarray) -> NDArray[np.float32]: ...

    class spectral:
        class EdgeMode(enum.IntEnum):
            linear = ...
            wrap = ...
            wrap_centre = ...
            fold = ...
            fold_repeat = ...

        class SmoothEdgeMode(enum.IntEnum):
            zero_pad = ...
            extend = ...
            wrap = ...
            fold = ...
            mirror = ...

        class SpectralProcessor:
            def __init__(self, max_fft_size: int = ...) -> None: ...
            def set_max_fft_size(self, size: int) -> None: ...
            def max_fft_size(self) -> int: ...
            def convolve(
                self,
                in1: np.ndarray,
                in2: np.ndarray,
                mode: hisstools.spectral.EdgeMode = ...,
            ) -> NDArray[np.float32]: ...
            def correlate(
                self,
                in1: np.ndarray,
                in2: np.ndarray,
                mode: hisstools.spectral.EdgeMode = ...,
            ) -> NDArray[np.float32]: ...
            def change_phase(
                self,
                input: np.ndarray,
                phase: float,
                time_multiplier: float = ...,
            ) -> NDArray[np.float32]: ...
            def convolved_size(
                self,
                size1: int,
                size2: int,
                mode: hisstools.spectral.EdgeMode = ...,
            ) -> int: ...
            def correlated_size(
                self,
                size1: int,
                size2: int,
                mode: hisstools.spectral.EdgeMode = ...,
            ) -> int: ...

        class KernelSmoother:
            def __init__(self, max_fft_size: int = ...) -> None: ...
            def smooth(
                self,
                input: np.ndarray,
                kernel: np.ndarray,
                width_lo: float,
                width_hi: float,
                symmetric: bool = ...,
                edges: hisstools.spectral.SmoothEdgeMode = ...,
            ) -> NDArray[np.float32]: ...

    class analysis:
        @staticmethod
        def stat_mean(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_rms(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_sum(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_min(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_max(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_min_position(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_max_position(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_variance(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_standard_deviation(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_centroid(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_spread(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_skewness(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_kurtosis(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_flatness(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_crest(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_product(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_geometric_mean(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_sum_abs(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_sum_squares(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_mean_squares(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_length(input: np.ndarray) -> float: ...
        @staticmethod
        def stat_pdf_percentile(input: np.ndarray, centile: float) -> float: ...
        @staticmethod
        def stat_count_above(input: np.ndarray, threshold: float) -> float: ...
        @staticmethod
        def stat_count_below(input: np.ndarray, threshold: float) -> float: ...

        class Peak:
            def __init__(self, freq: float = ..., amp: float = ...) -> None: ...
            def freq(self) -> float: ...
            def amp(self) -> float: ...
            def pitch(self) -> float: ...
            def db(self) -> float: ...

        class TrackState(enum.IntEnum):
            off = ...
            start = ...
            continue_ = ...
            switch = ...

        class Track:
            peak: hisstools.analysis.Peak
            state: hisstools.analysis.TrackState
            def __init__(self) -> None: ...
            def active(self) -> bool: ...

        class PartialTracker:
            def __init__(self, max_tracks: int, max_peaks: int) -> None: ...
            def set_cost_calculation(
                self, square_cost: bool, use_pitch: bool, use_db: bool
            ) -> None: ...
            def set_cost_scaling(
                self, freq_unit: float, amp_unit: float, max_cost: float
            ) -> None: ...
            def reset(self) -> None: ...
            def process(
                self, peaks: list[hisstools.analysis.Peak], start_threshold: float
            ) -> None: ...
            def get_track(self, index: int) -> hisstools.analysis.Track: ...
            def max_peaks(self) -> int: ...
            def max_tracks(self) -> int: ...

    class windows:
        @staticmethod
        def rect(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def triangle(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def welch(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def parzen(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def sine(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def hann(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def hamming(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def blackman(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def exact_blackman(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def blackman_harris_62dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def blackman_harris_71dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def blackman_harris_74dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def blackman_harris_92dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def nuttall_1st_64dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def nuttall_1st_93dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def nuttall_3rd_47dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def nuttall_3rd_83dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def nuttall_5th_61dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def nuttall_minimal_71dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def nuttall_minimal_98dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def ni_flat_top(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def hp_flat_top(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def stanford_flat_top(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def heinzel_flat_top_70dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def heinzel_flat_top_90dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def heinzel_flat_top_95dB(size: int) -> NDArray[np.float32]: ...
        @staticmethod
        def tukey(size: int, alpha: float) -> NDArray[np.float32]: ...
        @staticmethod
        def kaiser(size: int, beta: float) -> NDArray[np.float32]: ...
        @staticmethod
        def sine_taper(size: int, order: float) -> NDArray[np.float32]: ...
        @staticmethod
        def trapezoid(size: int, a: float, b: float) -> NDArray[np.float32]: ...
        @staticmethod
        def cosine_2_term(size: int, a0: float) -> NDArray[np.float32]: ...
        @staticmethod
        def cosine_3_term(
            size: int, a0: float, a1: float, a2: float
        ) -> NDArray[np.float32]: ...
        @staticmethod
        def cosine_4_term(
            size: int, a0: float, a1: float, a2: float, a3: float
        ) -> NDArray[np.float32]: ...
        @staticmethod
        def cosine_5_term(
            size: int, a0: float, a1: float, a2: float, a3: float, a4: float
        ) -> NDArray[np.float32]: ...

class choc:
    @staticmethod
    def read_flac(path: str) -> tuple[NDArray[np.float32], float]:
        """Read a FLAC file. Returns (data, sample_rate) where data is [channels, frames] float32."""
        ...
    @staticmethod
    def write_flac(
        path: str,
        data: NDArray[np.float32],
        sample_rate: float,
        bit_depth: int = 16,
    ) -> None:
        """Write audio data to a FLAC file. data is [channels, frames] float32."""
        ...

class grainflow:
    # --- Parameter name constants (gf_param_name) ---
    PARAM_ERR: int
    PARAM_DELAY: int
    PARAM_RATE: int
    PARAM_GLISSON: int
    PARAM_GLISSON_ROWS: int
    PARAM_GLISSON_POSITION: int
    PARAM_WINDOW: int
    PARAM_AMPLITUDE: int
    PARAM_SPACE: int
    PARAM_ENVELOPE_POSITION: int
    PARAM_N_ENVELOPES: int
    PARAM_DIRECTION: int
    PARAM_START_POINT: int
    PARAM_STOP_POINT: int
    PARAM_RATE_QUANTIZE_SEMI: int
    PARAM_LOOP_MODE: int
    PARAM_CHANNEL: int
    PARAM_DENSITY: int
    PARAM_VIBRATO_RATE: int
    PARAM_VIBRATO_DEPTH: int
    PARAM_TRANSPOSE: int
    PARAM_GLISSON_ST: int
    PARAM_STREAM: int

    # --- Parameter type constants (gf_param_type) ---
    PTYPE_ERR: int
    PTYPE_BASE: int
    PTYPE_RANDOM: int
    PTYPE_OFFSET: int
    PTYPE_MODE: int
    PTYPE_VALUE: int

    # --- Stream mode constants (gf_stream_set_type) ---
    STREAM_AUTOMATIC: int
    STREAM_PER: int
    STREAM_RANDOM: int
    STREAM_MANUAL: int

    # --- Buffer type constants (gf_buffers) ---
    BUF_BUFFER: int
    BUF_ENVELOPE: int
    BUF_RATE: int
    BUF_DELAY: int
    BUF_WINDOW: int
    BUF_GLISSON: int

    # --- Buffer mode constants (gf_buffer_mode) ---
    BUFMODE_NORMAL: int
    BUFMODE_SEQUENCE: int
    BUFMODE_RANDOM: int

    # --- Pan mode constants (gf_pan_mode) ---
    PAN_BIPOLAR: int
    PAN_UNIPOLAR: int
    PAN_STEREO: int

    class GfBuffer:
        def __init__(self, frames: int, channels: int, samplerate: int) -> None: ...
        def set_data(self, data: NDArray[np.float32]) -> None: ...
        def get_data(self) -> NDArray[np.float32]: ...
        @property
        def channels(self) -> int: ...
        @property
        def frames(self) -> int: ...
        @property
        def samplerate(self) -> int: ...

    class GrainCollection:
        def __init__(self, num_grains: int, samplerate: int) -> None: ...
        def set_buffer(
            self,
            buf: grainflow.GfBuffer,
            buf_type: int,
            target: int = 0,
        ) -> None: ...
        def set_buffer_str(
            self,
            buf: grainflow.GfBuffer,
            type_str: str,
            target: int = 0,
        ) -> None: ...
        def param_set(
            self,
            target: int,
            param_name: int,
            param_type: int,
            value: float,
        ) -> None: ...
        def param_set_str(self, target: int, name: str, value: float) -> int: ...
        def param_get(self, target: int, param_name: int) -> float: ...
        def param_get_typed(
            self, target: int, param_name: int, param_type: int
        ) -> float: ...
        def set_active_grains(self, n: int) -> None: ...
        @property
        def active_grains(self) -> int: ...
        @property
        def grains(self) -> int: ...
        def set_auto_overlap(self, v: bool) -> None: ...
        def get_auto_overlap(self) -> bool: ...
        def stream_set(self, mode: int, nstreams: int) -> None: ...
        def stream_set_manual(self, grain: int, stream_id: int) -> None: ...
        def stream_get(self, grain: int) -> int: ...
        @property
        def streams(self) -> int: ...
        def process(
            self,
            clock: NDArray[np.float32],
            traversal: NDArray[np.float32],
            fm: NDArray[np.float32],
            am: NDArray[np.float32],
            samplerate: int,
        ) -> tuple[
            NDArray[np.float32],
            NDArray[np.float32],
            NDArray[np.float32],
            NDArray[np.float32],
            NDArray[np.float32],
            NDArray[np.float32],
            NDArray[np.float32],
            NDArray[np.float32],
        ]: ...

    class Panner:
        def __init__(
            self,
            in_channels: int,
            out_channels: int = 2,
            pan_mode: int = 2,
        ) -> None: ...
        def set_pan_position(self, v: float) -> None: ...
        def set_pan_spread(self, v: float) -> None: ...
        def set_pan_quantization(self, v: float) -> None: ...
        @property
        def pan_position(self) -> float: ...
        @property
        def pan_spread(self) -> float: ...
        def process(
            self,
            grains: NDArray[np.float32],
            grain_states: NDArray[np.float32],
            out_channels: int = 2,
        ) -> NDArray[np.float32]: ...

    class Recorder:
        def __init__(self, samplerate: int) -> None: ...
        def set_target(self, frames: int, channels: int, samplerate: int) -> None: ...
        def set_n_filters(self, n: int) -> None: ...
        def set_filter_params(
            self, idx: int, freq: float, q: float, mix: float
        ) -> None: ...
        def process(
            self,
            input: NDArray[np.float32],
            time_override: float = 0.0,
        ) -> NDArray[np.float32]: ...
        def get_buffer_data(self) -> NDArray[np.float32]: ...
        @property
        def overdub(self) -> float: ...
        @overdub.setter
        def overdub(self, v: float) -> None: ...
        @property
        def freeze(self) -> bool: ...
        @freeze.setter
        def freeze(self, v: bool) -> None: ...
        @property
        def sync(self) -> bool: ...
        @sync.setter
        def sync(self, v: bool) -> None: ...
        @property
        def state(self) -> bool: ...
        @state.setter
        def state(self, v: bool) -> None: ...
        def set_rec_range(self, lo: float, hi: float) -> None: ...
        def get_rec_range(self) -> tuple[float, float]: ...

    class Phasor:
        def __init__(self, rate: float, samplerate: int) -> None: ...
        def set_rate(self, rate: float, samplerate: int) -> None: ...
        def perform(self, frames: int = 64) -> NDArray[np.float32]: ...
